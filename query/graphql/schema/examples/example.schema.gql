# This is an example schema for DefraDB GraphQL Query Language.
# It is the design of the auto-generated schema for a given developer
# defined type.

# Target types autogenerated from
type Book @collection("books") @schema("456@2") {
    title: String
    genre: String
    description: String
    rating: Int
    author: Author @relation
    published_by: JSON @type("Publisher")
}


type Author @collection("authors") @schema("123@1") {
    name: String
    bio: String
    books(filter: BookFilterArg, order: BookOrderArg): [Book] @relation
}

type Publisher {
    name: String
    ...
}

# Example auto-generated types

enum BookFields {
    title
    genre
    description
    rating
    author
}

# Note: Currently (Aug 2020) the GraphQL spec does not allow input union types. So the filter block fields must take another input object exclusively.
# This means, instead of "filter: {name: 'John'}", we MUST use "filter: {name: {_eq: 'John'}}"
# See the following RFC for updates: https://github.com/graphql/graphql-spec/pull/733

# Book filters with conditionals and relations
input BookFilterArg {
    # conditionals
    _and: [BookFilterArg]
    _or: [BookFilterArg]
    _not: BookFilterArg

    # fields
    title: StringOperatorBlock
    genre: StringOperatorBlock
    description: StringOperatorBlock
    rating: IntOperatorBlock

    # relations
    author: AuthorFilterBaseArg
}

# All the *BaseArg input types are used 
# when being filtered from a related type. This prevents
# malformed conditional positioning and infinite depth filters
# Conditionals are only allowed at the root level filter
# or directly inside another conditional.
# IE:   {_and: [{book: {rating: {_eq: 3}}}, {book: {title: {_eq: "A Painted}}}]} -  CORRECT
#       {book: {_and: [{rating: {_eq: 3}}, {title: {_eq: "A Painted}}]}} - INCORRECT
#
# Although this results in a few extra characters of syntax, its *much* easier to reason about
# Infinite depth filters would result from accessing both sides of a relationship indefinitely
# within a filter
# IE: {book: {author: {book: {author: ...}}}}
# By removing the relation objects from the base arg type we avoid this.

# Book filters without conditionals and relations
input BookFilterBaseArg {
    title: StringOperatorBlock
    genre: StringOperatorBlock
    description: StringOperatorBlock
    rating: IntOperatorBlock
}

# Having arguments
input BookHavingArg {
    _count: BookHavingBlock
    _min: BookHavingBlock
    _max: BookHavingBlock
    _sum: BookHavingBlock
    _avg: BookHavingBlock
}

input BookHavingBlock {
    title: FloatOperatorBlock
    genre: FloatOperatorBlock
    description: FloatOperatorBlock
    rating: FloatOperatorBlock
}

input BookOrderArg {
    title: Ordering
    genre: Ordering
    description: Ordering
    rating: Ordering
    author: AuthorOrderArg
}

enum AuthorFields {
    name
    bio
}

# Author  with conditionals and relations
input AuthorFilterArg {
    # conditionals
    _and: [AuthorFilterArg!]
    _or: [AuthorFilterArg!]
    _not: AuthorFilterArg

    #fields
    name: StringOperatorBlock
    bio: StringOperatorBlock

    # relations
    books: BookFilterBaseArg
}

# Author filters without conditionals and relations
input AuthorFilterBaseArg {
    name: StringOperatorBlock
    bio: StringOperatorBlock
}

# Having arguments
input AuthorHavingArg {
    _count: AuthorHavingBlock
    _min: AuthorHavingBlock
    _max: AuthorHavingBlock
    _sum: AuthorHavingBlock
    _avg: AuthorHavingBlock
}

input AuthorHavingArg {
    name: FloatOperatorBlock
    bio: FloatOperatorBlock
}

input AuthorOrderArg {
    name: Ordering
    bio: Ordering
}

type Query {
    books(filter: BookFilterArg, groupBy: [BookFields!], having: BookHavingArg, order: BookOrderArg, limit: Int, offset: Int) [Book]
    authors(filter: AuthorFilterArg, groupBy: [AuthorFields!], having: AuthorHavingArg, order: AuthorOrderArg, limit: Int, offset: Int) [Author]
}