###################################################
# THE FOLLOWING FILE IS AUTO-GENERATED BY DEFRADB #
# IT SHOULD NOT BE MANUALLY EDIT OR CHANGED.      #
###################################################

enum {TYPE_NAME}Fields {
    {FOR field in TYPE_NAME}
        {field}
    {END}
}

#  {TYPE_NAME} filters with conditionals and relations
input {TYPE_NAME}FilterArg {
    # condiationals
    _and: [{TYPE_NAME}FilterArg]!
    _or: [{TYPE_NAME}FilterArg!]
    _not: {TYPE_NAME}FilterArg

    # fields
    {FOR field in TYPE_NAME}
        {if field is scalar}
            {field}: {type(field)}OperatorBlock
        {end}
    {END}

    # relations
    {FOR field in TYPE_NAME}
        {if field is relation}
            {field}: {type(field)}FilterBaseArg
        {end}
    {END}
    
}

#  {TYPE_NAME} filters without conditionals and relations
input  {TYPE_NAME}FilterBaseArg {
    {FOR field in TYPE_NAME}
        {if field is scalar}
            {field}: {type(field)}OperatorBlock
        {end}
    {END}
}

# Having arguments
input {TYPE_NAME}HavingArg {
    _count: {TYPE_NAME}HavingBlock
    _min: {TYPE_NAME}HavingBlock
    _max: {TYPE_NAME}HavingBlock
    _sum: {TYPE_NAME}HavingBlock
    _avg: {TYPE_NAME}HavingBlock
}

# // @todo: _count supports no selection set, so the input type for Having should match.
input {TYPE_NAME}HavingBlock {
    {FOR field in TYPE_NAME}
        {if field is scalar}
            {field}: FloatOperatorBlock
        {end}
    {END}
}

input {TYPE_NAME}OrderArg {
    {FOR field in TYPE_NAME}
        {if field is scalar}
            {field}: Ordering
        {end}
    {END}

    {FOR field in TYPE_NAME}
        {if field is relation}
            {field}: {type(field)}OrderArg
        {end}
    {END}
}

extend type Query {
    {collection_name}(filter: {TYPE_NAME}FilterArg, groupBy: [{TYPE_NAME}Fields!], having: {TYPE_NAME}HavingArg, order: {TYPE_NAME}OrderArg, limit: Int, offset: Int) [{TYPE_NAME}]
}