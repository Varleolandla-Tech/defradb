// Copyright 2023 Democratized Data Foundation
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package gen

import (
	"math/rand"
	"reflect"

	"github.com/sourcenetwork/defradb/client"
	"github.com/sourcenetwork/defradb/client/request"
)

const (
	defaultNumDocs           = 10
	defaultNumChildrenPerDoc = 2

	defaultStrLen = 10
	defaultIntMin = 0
	defaultIntMax = 10000
)

type (
	doc = map[string]any

	docRec struct {
		doc    doc
		docKey string
	}
)

type configsMap map[string]map[string]genConfig

func (m configsMap) ForField(typeStr, fieldName string) genConfig {
	var fieldConfig genConfig
	typeConfig := m[typeStr]
	if typeConfig != nil {
		fieldConfig = typeConfig[fieldName]
	}
	return fieldConfig
}

func (m configsMap) AddForField(typeStr, fieldName string, conf genConfig) {
	typeConfig, ok := m[typeStr]
	if !ok {
		typeConfig = make(map[string]genConfig)
		m[typeStr] = typeConfig
	}
	typeConfig[fieldName] = conf
	m[typeStr] = typeConfig
}

func AutoGenerateDocs(schema string, options ...Option) ([]GeneratedDoc, error) {
	parser := schemaParser{}
	typeDefs, genConfigs, err := parser.Parse(schema)
	if err != nil {
		return nil, err
	}
	generator := randomDocGenerator{types: typeDefs, config: genConfigs}
	return generator.GenerateDocs(options...)
}

type relationUsage struct {
	index          int
	minAmount      int
	maxAmount      int
	docKeysCounter []struct {
		ind   int
		count int
	}
	numDocs int
}

func newRelationUsage(minAmount, maxAmount, numDocs int) relationUsage {
	docKeysCounter := make([]struct {
		ind   int
		count int
	}, numDocs)
	for i := range docKeysCounter {
		docKeysCounter[i].ind = i
	}
	return relationUsage{
		minAmount:      minAmount,
		maxAmount:      maxAmount,
		numDocs:        numDocs,
		docKeysCounter: docKeysCounter,
	}
}

func (u *relationUsage) useNextDocKey() int {
	docKeyCounterInd := 0
	if u.index >= u.minAmount*u.numDocs {
		docKeyCounterInd = rand.Intn(len(u.docKeysCounter))
	} else {
		docKeyCounterInd = u.index % len(u.docKeysCounter)
	}
	currentInd := u.docKeysCounter[docKeyCounterInd].ind
	counter := &u.docKeysCounter[docKeyCounterInd]
	counter.count++
	if counter.count >= u.maxAmount {
		lastCounterInd := len(u.docKeysCounter) - 1
		*counter = u.docKeysCounter[lastCounterInd]
		u.docKeysCounter = u.docKeysCounter[:lastCounterInd]
	}
	u.index++

	return currentInd
}

type randomDocGenerator struct {
	types        map[string]typeDefinition
	config       configsMap
	resultDocs   []GeneratedDoc
	usageCounter map[string]map[string]map[string]relationUsage
	cols         map[string][]docRec
	docsDemand   map[string]typeDemand
}

func (g *randomDocGenerator) GenerateDocs(options ...Option) ([]GeneratedDoc, error) {
	g.cols = make(map[string][]docRec)

	configurator := newDocGenConfigurator(g.types, g.config)
	err := configurator.Configure(options...)
	if err != nil {
		return nil, err
	}

	g.docsDemand = configurator.DocsDemand
	g.usageCounter = configurator.UsageCounter

	g.resultDocs = make([]GeneratedDoc, 0, g.getTotalDemand())
	docsLists := g.generateRandomDocs(configurator.TypesOrder)
	for _, docsList := range docsLists {
		typeDef := g.types[docsList.ColName]
		for _, doc := range docsList.Docs {
			g.resultDocs = append(g.resultDocs, GeneratedDoc{
				ColIndex: typeDef.index,
				JSON:     createDocJSON(&typeDef, doc),
			})
		}
	}
	return g.resultDocs, nil
}

func (g *randomDocGenerator) getTotalDemand() int {
	totalDemand := 0
	for _, demand := range g.docsDemand {
		totalDemand += demand.max
	}
	return totalDemand
}

func validateConfig(types map[string]typeDefinition, configsMap configsMap) error {
	for typeName, typeConfigs := range configsMap {
		typeDef := types[typeName]
		for fieldName, fieldConfig := range typeConfigs {
			fieldDef := typeDef.getField(fieldName)
			_, hasMin := fieldConfig.props["min"]
			if hasMin {
				var err error
				if fieldDef.isArray || fieldDef.typeStr == "Int" {
					err = validateMinConfig[int](&fieldConfig, fieldDef.isArray)
				} else {
					err = validateMinConfig[float64](&fieldConfig, false)
				}
				if err != nil {
					return err
				}
			} else if _, hasMax := fieldConfig.props["max"]; hasMax {
				return NewErrInvalidConfiguration("max value is set, but min value is not set")
			}
			lenConf, hasLen := fieldConfig.props["len"]
			if hasLen {
				if fieldDef.typeStr != "String" {
					return NewErrInvalidConfiguration("len val is used on  not String")
				}
				len, ok := lenConf.(int)
				if !ok {
					return NewErrInvalidConfiguration("len value is not integer")
				}
				if len < 1 {
					return NewErrInvalidConfiguration("len value is less than 1")
				}
			}
		}
	}
	return nil
}

func validateMinConfig[T int | float64](fieldConf *genConfig, onlyPositive bool) error {
	min, ok := fieldConf.props["min"].(T)
	if !ok {
		var t T
		return NewErrInvalidConfiguration("min value on array is not " + reflect.TypeOf(t).Name())
	}
	if min < 0 && onlyPositive {
		return NewErrInvalidConfiguration("min value on array is less than 0")
	}
	if maxProp, hasMax := fieldConf.props["max"]; hasMax {
		max, ok := maxProp.(T)
		if !ok && onlyPositive {
			var t T
			return NewErrInvalidConfiguration("max value for array is not " + reflect.TypeOf(t).Name())
		}
		if min > max {
			return NewErrInvalidConfiguration("min value on array is greater than max value")
		}
	} else {
		return NewErrInvalidConfiguration("min value is set, but max value is not set")
	}
	return nil
}

func (g *randomDocGenerator) getNextPrimaryDocKey(secondaryType string, field fieldDefinition) string {
	primaryType := field.typeStr
	current := g.usageCounter[primaryType][secondaryType][field.name]

	ind := current.useNextDocKey()

	docKey := g.cols[primaryType][ind].docKey
	g.usageCounter[primaryType][secondaryType][field.name] = current
	return docKey
}

func (g *randomDocGenerator) getDocKey(typeDef *typeDefinition, doc map[string]any) string {
	clientDoc, err := client.NewDocFromJSON([]byte(createDocJSON(typeDef, doc)))
	if err != nil {
		panic("failed to create doc from JSON: " + err.Error())
	}
	return clientDoc.Key().String()
}

func (g *randomDocGenerator) generateRandomDocs(order []string) []DocsList {
	result := []DocsList{}
	for _, typeName := range order {
		col := DocsList{ColName: typeName}
		typeDef := g.types[typeName]

		currentTypeDemand := g.docsDemand[typeName]
		averageDemand := currentTypeDemand.getAverage()
		for i := 0; i < averageDemand; i++ {
			newDoc := make(doc)
			for _, field := range typeDef.fields {
				if field.isRelation {
					if field.isPrimary {
						newDoc[field.name+request.RelatedObjectID] = g.getNextPrimaryDocKey(typeName, field)
					}
				} else {
					newDoc[field.name] = g.generateRandomValue(
						typeName,
						field.typeStr,
						g.config.ForField(typeName, field.name),
					)
				}
			}
			g.cols[typeName] = append(g.cols[typeName], docRec{doc: newDoc, docKey: g.getDocKey(&typeDef, newDoc)})
			col.Docs = append(col.Docs, newDoc)
		}
		result = append(result, col)
	}
	return result
}

func getMinMaxOrDefault[T int | float64](conf genConfig, min, max T) (T, T) {
	if prop, ok := conf.props["min"]; ok {
		min = prop.(T)
	}
	if prop, ok := conf.props["max"]; ok {
		max = prop.(T)
	}
	return min, max
}

func getRandomString(n int) string {
	const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	b := make([]byte, n)
	for i := range b {
		b[i] = letterBytes[rand.Intn(len(letterBytes))]
	}
	return string(b)
}

func (g *randomDocGenerator) generateRandomValue(typeName, fieldType string, fieldConfig genConfig) any {
	genVal := g.getValueGenerator(fieldType, fieldConfig)
	if fieldConfig.fieldGenerator != nil {
		return fieldConfig.fieldGenerator(len(g.cols[typeName]), genVal)
	}
	return genVal()
}

func (g *randomDocGenerator) getValueGenerator(typeStr string, fieldConfig genConfig) func() any {
	switch typeStr {
	case "String":
		strLen := defaultStrLen
		if prop, ok := fieldConfig.props["len"]; ok {
			strLen = prop.(int)
		}
		return func() any { return getRandomString(strLen) }
	case "Int":
		min, max := getMinMaxOrDefault(fieldConfig, defaultIntMin, defaultIntMax)
		return func() any { return min + rand.Intn(max-min+1) }
	case "Boolean":
		return func() any { return rand.Float32() < 0.5 }
	case "Float":
		min, max := getMinMaxOrDefault(fieldConfig, 0.0, 1.0)
		return func() any { return min + rand.Float64()*(max-min) }
	}
	panic("Can not generate random value for unknown type: " + typeStr)
}
