// Copyright 2023 Democratized Data Foundation
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package gen

import (
	"math"
	"testing"

	"github.com/stretchr/testify/assert"
)

func getField(t *testing.T, doc map[string]any, fieldName string) any {
	field, ok := doc[fieldName]
	assert.True(t, ok, "field %s not found", fieldName)
	return field
}

func getStringField(t *testing.T, doc map[string]any, fieldName string) string {
	val, ok := getField(t, doc, fieldName).(string)
	assert.True(t, ok, "field %s is not of type string", fieldName)
	return val
}

func getIntField(t *testing.T, doc map[string]any, fieldName string) int {
	switch val := getField(t, doc, fieldName).(type) {
	case int:
		return val
	case float64:
		return int(val)
	}
	assert.Fail(t, "field %s is not of type int or float64", fieldName)
	return 0
}

func getFloatField(t *testing.T, doc map[string]any, fieldName string) float64 {
	val, ok := getField(t, doc, fieldName).(float64)
	assert.True(t, ok, "field %s is not of type float64", fieldName)
	return val
}

func getBooleanField(t *testing.T, doc map[string]any, fieldName string) bool {
	val, ok := getField(t, doc, fieldName).(bool)
	assert.True(t, ok, "field %s is not of type bool", fieldName)
	return val
}

func TestAutoGenerateDocs_Simple(t *testing.T) {
	const numDocs = 1000
	schema := `
		type User {
			name: String
			age: Int
			verified: Boolean
			rating: Float
		}`

	docs := AutoGenerateDocs(schema, numDocs)

	assert.Len(t, docs, numDocs)
	userNames := make(map[string]bool, numDocs)
	userAges := make(map[int]bool, numDocs)
	userMinAge := math.MaxInt
	userMaxAge := math.MinInt
	userRatings := make(map[float64]bool, numDocs)
	userVerifiedCounter := 0
	userTotalRating := 0.0
	userMinRating := 1.0
	userMaxRating := 0.0

	for _, doc := range docs {
		docMap := jsonToMap(doc.JSON)

		name := getStringField(t, docMap, "name")
		assert.NotEmpty(t, name, "name is empty")
		userNames[name] = true

		age := getIntField(t, docMap, "age")
		if age < userMinAge {
			userMinAge = age
		}
		if age > userMaxAge {
			userMaxAge = age
		}
		userAges[age] = true

		if getBooleanField(t, docMap, "verified") {
			userVerifiedCounter++
		}

		rating := getFloatField(t, docMap, "rating")
		userRatings[rating] = true
		userMinRating = math.Min(userMinRating, rating)
		userMaxRating = math.Max(userMaxRating, rating)
		userTotalRating += rating
	}

	// assert that at least 99% of the names are unique
	assert.GreaterOrEqual(t, len(userNames), int(numDocs*0.99))

	// assert there at least 70% of ages are unique
	assert.GreaterOrEqual(t, len(userAges), int(numDocs*0.7))

	// assert that min and max age are not too far from the default boundaries
	const minIntVal = 0
	const maxIntVal = 10000
	intPrecision := ((maxIntVal - minIntVal) / numDocs) * 20
	assert.LessOrEqual(t, userMinAge, minIntVal+intPrecision)
	assert.GreaterOrEqual(t, userMaxAge, maxIntVal-intPrecision)

	// assert that at least 40% of users are verified
	assert.GreaterOrEqual(t, userVerifiedCounter, int(numDocs*0.4))

	// assert that average rating is between 0.40 and 0.60
	averageRating := userTotalRating / float64(numDocs)
	assert.GreaterOrEqual(t, averageRating, 0.40)
	assert.LessOrEqual(t, averageRating, 0.60)
	// assert that min and max rating are not too far from the default boundaries
	assert.LessOrEqual(t, userMinRating, 0.02)
	assert.GreaterOrEqual(t, userMaxRating, 0.98)
	// assert that at least 95% of ratings are unique
	assert.GreaterOrEqual(t, len(userRatings), int(numDocs*0.95))
}
